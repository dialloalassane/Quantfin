# -*- coding: utf-8 -*-
"""Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# Commented out IPython magic to ensure Python compatibility.
# Install required packages
!pip install pandas numpy matplotlib seaborn scipy yfinance ta-lib

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import yfinance as yf
from datetime import datetime, timedelta
import random
from typing import List, Dict, Tuple, Any, Optional
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

# TA-LIB installation
try:
    import talib
except:
    !wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz
    !tar -xzf ta-lib-0.4.0-src.tar.gz
#     %cd ta-lib/
    !./configure --prefix=/usr
    !make
    !make install
    !pip install TA-Lib
    import talib

print("âœ… All packages imported successfully!")

class DataManager:
    """Cryptocurrency data management and preprocessing"""

    def __init__(self):
        self.symbols = ['BTC-USD', 'ETH-USD', 'BNB-USD']

    def fetch_data(self, symbol: str, period: str = "1y", interval: str = "1d") -> pd.DataFrame:
        """Fetch cryptocurrency data from Yahoo Finance"""
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(period=period, interval=interval)

            if data.empty:
                raise ValueError(f"No data found for {symbol}")

            # Clean and prepare data
            data = data[['Open', 'High', 'Low', 'Close', 'Volume']]
            data.columns = ['open', 'high', 'low', 'close', 'volume']
            data.index.name = 'datetime'

            # Remove missing values
            data = data.dropna()

            print(f"âœ… Fetched {len(data)} records for {symbol}")
            return data

        except Exception as e:
            print(f"âŒ Error fetching data for {symbol}: {e}")
            return None

    def generate_sample_data(self, days: int = 365, base_price: float = 10000) -> pd.DataFrame:
        """Generate realistic sample cryptocurrency data"""
        np.random.seed(42)

        dates = pd.date_range(start='2024-01-01', periods=days, freq='D')
        n_points = len(dates)

        # Crypto-like returns with high volatility and trends
        returns = np.random.normal(0.001, 0.035, n_points)  # High volatility
        trends = np.sin(np.arange(n_points) * 2 * np.pi / 90) * 0.002  # Quarterly cycles
        jumps = np.random.choice([0, 1], size=n_points, p=[0.98, 0.02]) * np.random.normal(0, 0.05, n_points)

        total_returns = returns + trends + jumps
        prices = base_price * np.cumprod(1 + total_returns)

        # Generate OHLC data with realistic patterns
        data = pd.DataFrame(index=dates)
        data['close'] = prices

        # Realistic OHLC relationships
        data['open'] = data['close'].shift(1) * (1 + np.random.normal(0, 0.005, n_points))
        data['high'] = np.maximum(data['open'], data['close']) * (1 + np.abs(np.random.normal(0, 0.015, n_points)))
        data['low'] = np.minimum(data['open'], data['close']) * (1 - np.abs(np.random.normal(0, 0.015, n_points)))
        data['volume'] = np.random.lognormal(10, 1, n_points)

        # Ensure OHLC consistency
        data['high'] = np.maximum(data[['open', 'high', 'close']].max(axis=1), data['low'] * 1.001)
        data['low'] = np.minimum(data[['open', 'low', 'close']].min(axis=1), data['high'] * 0.999)

        data = data.dropna()
        print(f"âœ… Generated {len(data)} days of sample data")
        return data

    def calculate_technical_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """Calculate comprehensive technical indicators"""
        df = data.copy()

        # RSI
        df['rsi_14'] = talib.RSI(df['close'], timeperiod=14)
        df['rsi_28'] = talib.RSI(df['close'], timeperiod=28)

        # Moving Averages
        df['sma_10'] = talib.SMA(df['close'], timeperiod=10)
        df['sma_20'] = talib.SMA(df['close'], timeperiod=20)
        df['sma_50'] = talib.SMA(df['close'], timeperiod=50)

        # Bollinger Bands
        df['bb_upper'], df['bb_middle'], df['bb_lower'] = talib.BBANDS(df['close'], timeperiod=20)

        # MACD
        df['macd'], df['macd_signal'], df['macd_hist'] = talib.MACD(df['close'])

        # ATR for volatility
        df['atr'] = talib.ATR(df['high'], df['low'], df['close'], timeperiod=14)

        return df

class ScalpingStrategy:
    """RSI-based Scalping Strategy as described in the paper"""

    def __init__(self, parameters: Dict[str, Any], initial_capital: float = 10000):
        self.parameters = parameters
        self.initial_capital = initial_capital
        self.position = 0
        self.cash = initial_capital
        self.trades = []
        self.portfolio_values = []

    def calculate_rsi(self, prices: pd.Series, period: int) -> pd.Series:
        """Calculate RSI indicator"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi.fillna(50)  # Fill NA with neutral value

    def apply_filters(self, data: pd.DataFrame, signal: pd.Series) -> pd.Series:
        """Apply trading filters as per paper"""
        filtered_signal = signal.copy()

        # Fast Moving Average Filter (FMAF)
        if self.parameters.get('fmaf', False):
            fast_ma = data['close'].rolling(window=10).mean()
            filtered_signal = np.where(data['close'] > fast_ma, filtered_signal, 0)

        # Slow Moving Average Filter (SMAF)
        if self.parameters.get('smaf', False):
            slow_ma = data['close'].rolling(window=20).mean()
            filtered_signal = np.where(data['close'] > slow_ma, filtered_signal, 0)

        # Slope Filter (SF)
        if self.parameters.get('sf', False):
            # Calculate slope using ATR normalization as mentioned in paper
            atr = talib.ATR(data['high'], data['low'], data['close'], timeperiod=14)
            price_slope = data['close'].diff(5) / data['close'].shift(5)
            normalized_slope = price_slope / (atr / data['close'])
            filtered_signal = np.where(normalized_slope > 0, filtered_signal, 0)

        return filtered_signal

    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """Generate trading signals based on RSI crossover"""
        df = data.copy()

        # Get RSI parameters
        rsi1_length = self.parameters.get('rsi1_length', 14)
        rsi2_length = self.parameters.get('rsi2_length', 28)

        # Calculate RSI values
        df['rsi_fast'] = self.calculate_rsi(df['close'], rsi1_length)
        df['rsi_slow'] = self.calculate_rsi(df['close'], rsi2_length)

        # Generate crossover signals
        df['rsi_cross'] = np.where(df['rsi_fast'] > df['rsi_slow'], 1, -1)
        df['raw_signal'] = df['rsi_cross'].diff()

        # Apply filters
        df['signal'] = self.apply_filters(df, df['raw_signal'])

        # Clean signals (only take the crossover points)
        df['final_signal'] = 0
        buy_signals = (df['signal'] > 0) & (df['rsi_fast'] < 70)  # Avoid overbought
        sell_signals = (df['signal'] < 0) & (df['rsi_fast'] > 30)  # Avoid oversold

        df.loc[buy_signals, 'final_signal'] = 1
        df.loc[sell_signals, 'final_signal'] = -1

        return df

    def execute_backtest(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Execute complete backtest"""
        signals_data = self.generate_signals(data)

        # Reset state
        self.position = 0
        self.cash = self.initial_capital
        self.trades = []
        self.portfolio_values = []

        for i, (idx, row) in enumerate(signals_data.iterrows()):
            current_price = row['close']

            # Buy signal
            if row['final_signal'] == 1 and self.position == 0:
                # Calculate position size (use 95% of capital to leave room for fees)
                position_size = (self.cash * 0.95) / current_price
                self.position = position_size
                self.cash -= position_size * current_price

                self.trades.append({
                    'timestamp': idx,
                    'type': 'BUY',
                    'price': current_price,
                    'size': position_size,
                    'value': position_size * current_price
                })

            # Sell signal
            elif row['final_signal'] == -1 and self.position > 0:
                sale_value = self.position * current_price
                self.cash += sale_value

                self.trades.append({
                    'timestamp': idx,
                    'type': 'SELL',
                    'price': current_price,
                    'size': self.position,
                    'value': sale_value
                })
                self.position = 0

            # Calculate portfolio value
            current_value = self.cash + (self.position * current_price)
            self.portfolio_values.append(current_value)

        # Calculate performance metrics
        returns = self.calculate_returns()
        metrics = self.calculate_performance_metrics(returns)

        return metrics

    def calculate_returns(self) -> pd.Series:
        """Calculate daily returns from portfolio values"""
        if len(self.portfolio_values) <= 1:
            return pd.Series([0])
        portfolio_series = pd.Series(self.portfolio_values)
        returns = portfolio_series.pct_change().dropna()
        return returns

    def calculate_performance_metrics(self, returns: pd.Series) -> Dict[str, float]:
        """Calculate comprehensive performance metrics"""
        if len(returns) == 0 or len(self.portfolio_values) == 0:
            return self._get_default_metrics()

        total_return = (self.portfolio_values[-1] / self.initial_capital - 1) * 100
        annual_return = total_return * (365 / len(returns)) if len(returns) > 0 else 0

        # Sharpe Ratio (assuming 2% risk-free rate)
        excess_returns = returns - 0.02/365
        sharpe_ratio = excess_returns.mean() / returns.std() * np.sqrt(365) if returns.std() > 0 else 0

        # Sortino Ratio (downside deviation)
        downside_returns = returns[returns < 0]
        downside_std = downside_returns.std() if len(downside_returns) > 0 else 0.001
        sortino_ratio = excess_returns.mean() / downside_std * np.sqrt(365) if downside_std > 0 else 0

        # Maximum Drawdown
        portfolio_array = np.array(self.portfolio_values)
        peak = np.maximum.accumulate(portfolio_array)
        drawdown = (peak - portfolio_array) / peak
        max_drawdown = np.max(drawdown) * 100 if len(drawdown) > 0 else 0

        # Volatility (annualized)
        volatility = returns.std() * np.sqrt(365) * 100 if returns.std() > 0 else 0

        # Trading statistics
        trade_stats = self.calculate_trade_statistics()

        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'sharpe_ratio': sharpe_ratio,
            'sortino_ratio': sortino_ratio,
            'max_drawdown': max_drawdown,
            'volatility': volatility,
            'win_rate': trade_stats['win_rate'],
            'profit_factor': trade_stats['profit_factor'],
            'total_trades': trade_stats['total_trades'],
            'avg_trade_return': trade_stats['avg_trade_return'],
            'portfolio_values': self.portfolio_values.copy(),
            'trades': self.trades.copy()
        }

    def _get_default_metrics(self) -> Dict[str, float]:
        """Return default metrics when no trading occurs"""
        return {
            'total_return': 0,
            'annual_return': 0,
            'sharpe_ratio': 0,
            'sortino_ratio': 0,
            'max_drawdown': 0,
            'volatility': 0,
            'win_rate': 0,
            'profit_factor': 0,
            'total_trades': 0,
            'avg_trade_return': 0,
            'portfolio_values': [self.initial_capital],
            'trades': []
        }

    def calculate_trade_statistics(self) -> Dict[str, float]:
        """Calculate trading statistics"""
        if len(self.trades) < 2:
            return {'win_rate': 0, 'profit_factor': 0, 'total_trades': 0, 'avg_trade_return': 0}

        trade_returns = []
        i = 0
        while i < len(self.trades) - 1:
            if self.trades[i]['type'] == 'BUY' and self.trades[i+1]['type'] == 'SELL':
                buy_price = self.trades[i]['price']
                sell_price = self.trades[i+1]['price']
                trade_return = (sell_price - buy_price) / buy_price
                trade_returns.append(trade_return)
                i += 2
            else:
                i += 1

        if not trade_returns:
            return {'win_rate': 0, 'profit_factor': 0, 'total_trades': 0, 'avg_trade_return': 0}

        win_rate = len([r for r in trade_returns if r > 0]) / len(trade_returns) * 100
        avg_trade_return = np.mean(trade_returns) * 100

        # Profit Factor
        gross_profit = sum([r for r in trade_returns if r > 0])
        gross_loss = abs(sum([r for r in trade_returns if r < 0]))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')

        return {
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'total_trades': len(trade_returns),
            'avg_trade_return': avg_trade_return
        }

class AnalysisAgent:
    """A_anal: Determines optimization directions based on market data"""

    def analyze(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Analyze market conditions and determine optimization directions"""

        # Calculate market regime indicators
        volatility = data['close'].pct_change().std() * np.sqrt(365)  # Annualized volatility
        trend_strength = self.calculate_trend_strength(data)

        # Determine optimization directions based on paper's methodology
        directions = {}

        # RSI fast length: shorter for trending markets, longer for ranging
        if trend_strength > 0.6:  # Strong trend
            directions['rsi1_length'] = 'decrease'  # Shorter for faster signals
        else:
            directions['rsi1_length'] = 'increase'  # Longer to reduce noise

        # RSI slow length: adaptive to market volatility
        if volatility > 0.8:  # High volatility
            directions['rsi2_length'] = 'increase'  # Longer to filter noise
        else:
            directions['rsi2_length'] = 'decrease'  # Shorter for responsiveness

        # Filter activation based on market conditions
        directions['fmaf'] = 'enable' if trend_strength > 0.4 else 'disable'
        directions['smaf'] = 'enable' if volatility < 0.6 else 'disable'
        directions['sf'] = 'enable' if volatility > 0.7 else 'disable'

        return directions

    def calculate_trend_strength(self, data: pd.DataFrame) -> float:
        """Calculate trend strength using ADX"""
        try:
            adx = talib.ADX(data['high'], data['low'], data['close'], timeperiod=14)
            adx_mean = np.nanmean(adx)
            return adx_mean / 100 if not np.isnan(adx_mean) else 0.3  # Normalize to 0-1
        except:
            # Fallback: use slope of linear regression
            x = np.arange(len(data))
            y = data['close'].values
            slope = np.polyfit(x, y, 1)[0]
            return min(abs(slope / data['close'].mean()) * 1000, 1.0)

class GenerateAgent:
    """A_gen: Generates initial population based on optimization directions"""

    def __init__(self):
        self.param_ranges = {
            'rsi1_length': (5, 30),
            'rsi2_length': (15, 50)
        }

    def generate_initial_population(self, size: int, directions: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate initial population following optimization directions"""
        population = []

        for _ in range(size):
            individual = {}

            # RSI1 Length with direction bias
            rsi1_min, rsi1_max = self.param_ranges['rsi1_length']
            if directions['rsi1_length'] == 'decrease':
                individual['rsi1_length'] = random.randint(rsi1_min, (rsi1_min + rsi1_max) // 3)
            else:
                individual['rsi1_length'] = random.randint((rsi1_min + rsi1_max) * 2 // 3, rsi1_max)

            # RSI2 Length with direction bias
            rsi2_min, rsi2_max = self.param_ranges['rsi2_length']
            if directions['rsi2_length'] == 'decrease':
                individual['rsi2_length'] = random.randint(rsi2_min, (rsi2_min + rsi2_max) // 3)
            else:
                individual['rsi2_length'] = random.randint((rsi2_min + rsi2_max) * 2 // 3, rsi2_max)

            # Ensure RSI fast < RSI slow
            if individual['rsi1_length'] >= individual['rsi2_length']:
                individual['rsi2_length'] = individual['rsi1_length'] + random.randint(5, 15)

            # Filter parameters
            individual['fmaf'] = directions['fmaf'] == 'enable'
            individual['smaf'] = directions['smaf'] == 'enable'
            individual['sf'] = directions['sf'] == 'enable'

            population.append(individual)

        return population

class EvaluateAgent:
    """A_eval: Evaluates fitness of parameter sets"""

    def __init__(self):
        # Comprehensive fitness weights as per paper
        self.metric_weights = {
            'sharpe_ratio': 0.25,
            'sortino_ratio': 0.20,
            'annual_return': 0.15,
            'max_drawdown': -0.15,  # Negative weight - lower is better
            'win_rate': 0.10,
            'profit_factor': 0.10,
            'total_trades': 0.05    # Encourage reasonable trading frequency
        }

    def evaluate_population(self, population: List[Dict[str, Any]], data: pd.DataFrame) -> List[float]:
        """Evaluate fitness for entire population"""
        fitness_scores = []

        for i, params in enumerate(population):
            try:
                fitness = self.evaluate_individual(params, data)
                fitness_scores.append(fitness)
            except Exception as e:
                print(f"âŒ Error evaluating individual {i}: {e}")
                fitness_scores.append(-9999)  # Very low fitness for failed evaluations

        return fitness_scores

    def evaluate_individual(self, params: Dict[str, Any], data: pd.DataFrame) -> float:
        """Evaluate fitness of a single parameter set"""
        strategy = ScalpingStrategy(params)
        results = strategy.execute_backtest(data)

        # Normalize metrics and calculate weighted fitness
        fitness = 0

        for metric, weight in self.metric_weights.items():
            if metric in results:
                normalized_value = self.normalize_metric(metric, results[metric])
                fitness += normalized_value * weight

        # Penalize insufficient trading activity
        if results['total_trades'] < 3:
            fitness *= 0.3
        elif results['total_trades'] < 5:
            fitness *= 0.7

        return fitness

    def normalize_metric(self, metric: str, value: float) -> float:
        """Normalize metric to reasonable scale"""
        if metric == 'max_drawdown':  # Lower is better (0-50% range)
            normalized = 1.0 - min(abs(value) / 50.0, 1.0)
        elif metric == 'sharpe_ratio':  # Typically -1 to 3
            normalized = (value + 1) / 4.0
        elif metric == 'sortino_ratio':  # Typically -1 to 5
            normalized = (value + 1) / 6.0
        elif metric == 'annual_return':  # -100% to +500%
            normalized = (value + 100) / 600.0
        elif metric == 'win_rate':  # 0-100%
            normalized = value / 100.0
        elif metric == 'profit_factor':  # 0 to 10
            normalized = min(value / 10.0, 1.0)
        elif metric == 'total_trades':  # 0 to 100 trades
            normalized = min(value / 100.0, 1.0)
        else:
            normalized = 0

        return max(0, min(1, normalized))  # Clamp between 0 and 1

class ChooseAgent:
    """A_cho: Selects elite individuals for next generation"""

    def __init__(self, elite_threshold: float = 0.2):
        self.elite_threshold = elite_threshold

    def select(self, population: List[Dict[str, Any]], fitness_scores: List[float]) -> List[Dict[str, Any]]:
        """Select elite individuals using tournament selection"""
        if len(population) == 0:
            return []

        # Sort by fitness
        sorted_indices = np.argsort(fitness_scores)[::-1]  # Descending
        sorted_population = [population[i] for i in sorted_indices]

        # Elite selection (top 20%)
        elite_count = max(1, int(len(population) * self.elite_threshold))
        elite_population = sorted_population[:elite_count]

        # Weighted selection for remaining individuals
        remaining_count = len(population) - elite_count

        if remaining_count > 0 and elite_count < len(population):
            # Use fitness-based weights for selection from non-elite
            non_elite_fitness = [fitness_scores[i] for i in sorted_indices[elite_count:]]
            weights = self.calculate_selection_weights(non_elite_fitness)

            if len(weights) > 0:
                selected_indices = np.random.choice(
                    range(len(non_elite_fitness)),
                    size=remaining_count,
                    p=weights,
                    replace=True
                )

                for idx in selected_indices:
                    elite_population.append(sorted_population[elite_count + idx])

        return elite_population

    def calculate_selection_weights(self, fitness_scores: List[float]) -> np.ndarray:
        """Calculate selection weights using paper's formula"""
        if len(fitness_scores) == 0:
            return np.array([])

        min_fitness = min(fitness_scores)
        adjusted_scores = [max(0, score - min_fitness + 0.1) for score in fitness_scores]  # Add small constant
        total = sum(adjusted_scores)

        if total == 0:
            return np.ones(len(fitness_scores)) / len(fitness_scores)

        return np.array(adjusted_scores) / total

class CrossoverAgent:
    """A_cross: Performs crossover operations with market intelligence"""

    def __init__(self, crossover_rate: float = 0.8):
        self.crossover_rate = crossover_rate

    def crossover(self, population: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Perform crossover operations"""
        new_population = []

        # Always keep the original population
        for individual in population:
            new_population.append(individual.copy())

        # Generate offspring through crossover until we have enough
        while len(new_population) < len(population) * 1.5:
            if random.random() < self.crossover_rate and len(population) >= 2:
                parent1, parent2 = random.sample(population, 2)
                child = self.single_point_crossover(parent1, parent2)
                new_population.append(child)

        # Ensure RSI fast < RSI slow constraint
        for individual in new_population:
            if individual['rsi1_length'] >= individual['rsi2_length']:
                individual['rsi2_length'] = individual['rsi1_length'] + random.randint(1, 10)

        return new_population

    def single_point_crossover(self, parent1: Dict[str, Any], parent2: Dict[str, Any]) -> Dict[str, Any]:
        """Single-point crossover operation"""
        child = {}
        keys = list(parent1.keys())
        crossover_point = random.randint(1, len(keys) - 1)

        for i, key in enumerate(keys):
            if i < crossover_point:
                child[key] = parent1[key]
            else:
                child[key] = parent2[key]

        return child

class MutationAgent:
    """A_mut: Performs mutation operations with adaptive rates"""

    def __init__(self, mutation_rate: float = 0.15):
        self.mutation_rate = mutation_rate
        self.param_ranges = {
            'rsi1_length': (5, 30),
            'rsi2_length': (15, 50)
        }

    def mutate(self, population: List[Dict[str, Any]], best_individual: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Apply mutation to population"""
        mutated_population = []

        for individual in population:
            if random.random() < self.mutation_rate:
                mutated_individual = self.apply_mutation(individual, best_individual)
                mutated_population.append(mutated_individual)
            else:
                mutated_population.append(individual.copy())

        return mutated_population

    def apply_mutation(self, individual: Dict[str, Any], best_individual: Dict[str, Any]) -> Dict[str, Any]:
        """Apply mutation to an individual"""
        mutated = individual.copy()

        # Choose mutation type
        mutation_type = random.choice(['random', 'guided'])
        param_to_mutate = random.choice(list(mutated.keys()))

        if mutation_type == 'random':
            # Random mutation
            if isinstance(mutated[param_to_mutate], bool):
                mutated[param_to_mutate] = not mutated[param_to_mutate]
            else:
                range_min, range_max = self.param_ranges.get(param_to_mutate, (0, 100))
                mutated[param_to_mutate] = random.randint(range_min, range_max)

        else:  # guided mutation
            if param_to_mutate in best_individual:
                if isinstance(mutated[param_to_mutate], bool):
                    mutated[param_to_mutate] = best_individual[param_to_mutate]
                else:
                    # Move towards best value
                    current = mutated[param_to_mutate]
                    best = best_individual[param_to_mutate]
                    step = 1 if best > current else -1
                    mutated[param_to_mutate] = current + step

        # Ensure constraints
        if 'rsi1_length' in mutated and 'rsi2_length' in mutated:
            if mutated['rsi1_length'] >= mutated['rsi2_length']:
                mutated['rsi2_length'] = mutated['rsi1_length'] + random.randint(1, 10)

        return mutated

class CGAAgent:
    """Complete Crypto Genetic Algorithm Agent Framework"""

    def __init__(self,
                 population_size: int = 50,
                 elite_threshold: float = 0.2,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.15,
                 max_generations: int = 100):

        self.population_size = population_size
        self.elite_threshold = elite_threshold
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.max_generations = max_generations

        # Initialize all agents
        self.analysis_agent = AnalysisAgent()
        self.generate_agent = GenerateAgent()
        self.evaluate_agent = EvaluateAgent()
        self.choose_agent = ChooseAgent(elite_threshold)
        self.crossover_agent = CrossoverAgent(crossover_rate)
        self.mutation_agent = MutationAgent(mutation_rate)

        # Tracking
        self.best_individual = None
        self.best_fitness = -np.inf
        self.fitness_history = []

    def optimize(self, data: pd.DataFrame, verbose: bool = True) -> Dict[str, Any]:
        """Main optimization loop"""
        if verbose:
            print("ðŸš€ Starting CGA-Agent Optimization")
            print("=" * 50)

        # Step 1: Analysis and Initialization (A_anal + A_gen)
        if verbose:
            print("ðŸ“Š Phase 1: Market Analysis and Population Initialization")

        optimization_directions = self.analysis_agent.analyze(data)
        population = self.generate_agent.generate_initial_population(
            self.population_size, optimization_directions
        )

        if verbose:
            print(f"   Market Analysis: {optimization_directions}")
            print(f"   Initial population: {len(population)} individuals")

        # Optimization loop
        for generation in range(self.max_generations):
            if verbose and (generation % 10 == 0 or generation == self.max_generations - 1):
                print(f"   Generation {generation + 1}/{self.max_generations}")

            # Step 2: Evaluation (A_eval)
            fitness_scores = self.evaluate_agent.evaluate_population(population, data)

            # Update best individual
            current_best_idx = np.argmax(fitness_scores)
            current_best_fitness = fitness_scores[current_best_idx]

            if current_best_fitness > self.best_fitness:
                self.best_fitness = current_best_fitness
                self.best_individual = population[current_best_idx].copy()

            # Track progress
            self.fitness_history.append({
                'generation': generation,
                'best_fitness': self.best_fitness,
                'avg_fitness': np.mean(fitness_scores),
                'std_fitness': np.std(fitness_scores)
            })

            # Step 3: Selection (A_cho)
            elite_population = self.choose_agent.select(population, fitness_scores)

            # Step 4: Crossover (A_cross)
            offspring_population = self.crossover_agent.crossover(elite_population)

            # Step 5: Mutation (A_mut)
            population = self.mutation_agent.mutate(offspring_population, self.best_individual)

            # Ensure population size
            population = population[:self.population_size]

            # Check convergence
            if self.check_convergence() and generation > 20:
                if verbose:
                    print(f"   âœ… Convergence reached at generation {generation + 1}")
                break

        if verbose:
            print("ðŸŽ¯ Optimization completed!")
            print(f"   Best Fitness: {self.best_fitness:.4f}")
            print(f"   Best Parameters: {self.best_individual}")

        return self.best_individual

    def check_convergence(self, window: int = 10, threshold: float = 0.001) -> bool:
        """Check if the algorithm has converged"""
        if len(self.fitness_history) < window * 2:
            return False

        recent_fitness = [fh['best_fitness'] for fh in self.fitness_history[-window:]]
        previous_fitness = [fh['best_fitness'] for fh in self.fitness_history[-window*2:-window]]

        if len(recent_fitness) == 0 or len(previous_fitness) == 0:
            return False

        recent_avg = np.mean(recent_fitness)
        previous_avg = np.mean(previous_fitness)

        if abs(previous_avg) < 1e-10:
            return False

        improvement = abs(recent_avg - previous_avg) / abs(previous_avg)
        return improvement < threshold

    def get_optimization_report(self) -> pd.DataFrame:
        """Generate optimization progress report"""
        return pd.DataFrame(self.fitness_history)

    def plot_optimization_progress(self):
        """Plot optimization progress"""
        if not self.fitness_history:
            print("âŒ No optimization data available")
            return

        df = self.get_optimization_report()

        plt.figure(figsize=(12, 8))

        # Fitness progression
        plt.plot(df['generation'], df['best_fitness'], 'b-', label='Best Fitness', linewidth=2)
        plt.plot(df['generation'], df['avg_fitness'], 'r--', label='Average Fitness', alpha=0.7)
        plt.fill_between(df['generation'],
                        df['avg_fitness'] - df['std_fitness'],
                        df['avg_fitness'] + df['std_fitness'],
                        alpha=0.2, color='red', label='Â±1 Std Dev')

        plt.xlabel('Generation')
        plt.ylabel('Fitness Score')
        plt.title('CGA-Agent Optimization Progress')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

class BacktestingFramework:
    """Comprehensive backtesting framework for strategy evaluation"""

    def __init__(self, initial_capital: float = 10000):
        self.initial_capital = initial_capital

    def run_comparison(self, baseline_params: Dict[str, Any],
                      optimized_params: Dict[str, Any],
                      data: pd.DataFrame) -> Tuple[Dict[str, Any], Dict[str, Any]]:
        """Run comparison between baseline and optimized strategies"""

        print("ðŸ“ˆ Running Backtest Comparison")
        print("=" * 40)

        # Baseline strategy
        print("1. Testing Baseline Strategy...")
        baseline_strategy = ScalpingStrategy(baseline_params, self.initial_capital)
        baseline_results = baseline_strategy.execute_backtest(data)

        # Optimized strategy
        print("2. Testing Optimized Strategy...")
        optimized_strategy = ScalpingStrategy(optimized_params, self.initial_capital)
        optimized_results = optimized_strategy.execute_backtest(data)

        return baseline_results, optimized_results

    def calculate_improvement(self, baseline: Dict[str, Any], optimized: Dict[str, Any]) -> Dict[str, float]:
        """Calculate performance improvement metrics"""
        improvement = {}

        metrics_to_compare = ['total_return', 'annual_return', 'sharpe_ratio',
                             'sortino_ratio', 'win_rate', 'profit_factor',
                             'max_drawdown', 'volatility']

        for metric in metrics_to_compare:
            if metric in baseline and metric in optimized:
                base_val = baseline[metric]
                opt_val = optimized[metric]

                if base_val != 0:
                    if metric in ['max_drawdown', 'volatility']:
                        # For metrics where lower is better
                        improvement[metric] = ((base_val - opt_val) / abs(base_val)) * 100
                    else:
                        # For metrics where higher is better
                        improvement[metric] = ((opt_val - base_val) / abs(base_val)) * 100
                else:
                    improvement[metric] = opt_val * 100 if opt_val != 0 else 0

        return improvement

    def generate_report(self, baseline: Dict[str, Any], optimized: Dict[str, Any],
                       improvement: Dict[str, float]) -> pd.DataFrame:
        """Generate comprehensive performance report"""

        metrics = ['total_return', 'annual_return', 'sharpe_ratio', 'sortino_ratio',
                  'max_drawdown', 'volatility', 'win_rate', 'profit_factor', 'total_trades']

        report_data = []
        for metric in metrics:
            if metric in baseline and metric in optimized:
                # Format values with appropriate units
                baseline_val = baseline[metric]
                optimized_val = optimized[metric]
                imp_val = improvement.get(metric, 0)

                # Determine units
                if any(x in metric for x in ['return', 'drawdown', 'rate', 'volatility']):
                    baseline_str = f"{baseline_val:.2f}%"
                    optimized_str = f"{optimized_val:.2f}%"
                else:
                    baseline_str = f"{baseline_val:.2f}"
                    optimized_str = f"{optimized_val:.2f}"

                report_data.append({
                    'Metric': metric.replace('_', ' ').title(),
                    'Baseline': baseline_str,
                    'Optimized': optimized_str,
                    'Improvement': f"{imp_val:+.1f}%"
                })

        return pd.DataFrame(report_data)

    def plot_comparison(self, baseline: Dict[str, Any], optimized: Dict[str, Any]):
        """Plot comprehensive comparison charts"""

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))

        # Portfolio growth comparison
        if 'portfolio_values' in baseline and 'portfolio_values' in optimized:
            baseline_portfolio = baseline['portfolio_values']
            optimized_portfolio = optimized['portfolio_values']

            min_len = min(len(baseline_portfolio), len(optimized_portfolio))
            days = range(min_len)

            ax1.plot(days, baseline_portfolio[:min_len], 'b-', label='Baseline', linewidth=2, alpha=0.8)
            ax1.plot(days, optimized_portfolio[:min_len], 'r-', label='Optimized', linewidth=2, alpha=0.8)
            ax1.set_xlabel('Trading Days')
            ax1.set_ylabel('Portfolio Value ($)')
            ax1.set_title('Portfolio Growth Comparison')
            ax1.legend()
            ax1.grid(True, alpha=0.3)
            ax1.ticklabel_format(style='plain', axis='y')

        # Key metrics comparison
        metrics = ['Total Return', 'Sharpe Ratio', 'Sortino Ratio']
        baseline_vals = [baseline['total_return'], baseline['sharpe_ratio'], baseline['sortino_ratio']]
        optimized_vals = [optimized['total_return'], optimized['sharpe_ratio'], optimized['sortino_ratio']]

        x = np.arange(len(metrics))
        width = 0.35

        ax2.bar(x - width/2, baseline_vals, width, label='Baseline', alpha=0.7, color='blue')
        ax2.bar(x + width/2, optimized_vals, width, label='Optimized', alpha=0.7, color='red')
        ax2.set_xlabel('Metrics')
        ax2.set_ylabel('Values')
        ax2.set_title('Key Performance Metrics')
        ax2.set_xticks(x)
        ax2.set_xticklabels(metrics)
        ax2.legend()
        ax2.grid(True, alpha=0.3)

        # Risk metrics comparison
        risk_metrics = ['Max Drawdown', 'Volatility']
        baseline_risk = [baseline['max_drawdown'], baseline['volatility']]
        optimized_risk = [optimized['max_drawdown'], optimized['volatility']]

        ax3.bar(risk_metrics, baseline_risk, alpha=0.7, label='Baseline', color='blue')
        ax3.bar(risk_metrics, optimized_risk, alpha=0.7, label='Optimized', color='red')
        ax3.set_ylabel('Percentage (%)')
        ax3.set_title('Risk Metrics Comparison')
        ax3.legend()
        ax3.grid(True, alpha=0.3)

        # Trading statistics
        trade_metrics = ['Win Rate', 'Total Trades']
        baseline_trade = [baseline['win_rate'], baseline['total_trades']]
        optimized_trade = [optimized['win_rate'], optimized['total_trades']]

        ax4.bar(trade_metrics, baseline_trade, alpha=0.7, label='Baseline', color='blue')
        ax4.bar(trade_metrics, optimized_trade, alpha=0.7, label='Optimized', color='red')
        ax4.set_ylabel('Values')
        ax4.set_title('Trading Statistics')
        ax4.legend()
        ax4.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

def run_complete_analysis():
    """Run complete CGA-Agent analysis"""
    print("ðŸ¤– Crypto Trading Strategy Optimization using CGA-Agent")
    print("=" * 60)

    # Initialize components
    data_manager = DataManager()
    backtester = BacktestingFramework()

    # Generate or fetch data
    print("1. ðŸ“Š Preparing Market Data...")
    data = data_manager.generate_sample_data(days=252)  # 1 year of data
    data = data_manager.calculate_technical_indicators(data)

    print(f"   Data prepared: {len(data)} trading days")

    # Define baseline parameters (from paper)
    baseline_params = {
        'rsi1_length': 14,
        'rsi2_length': 28,
        'fmaf': False,
        'smaf': False,
        'sf': False
    }

    # Initialize CGA-Agent
    print("\n2. ðŸ”§ Initializing CGA-Agent Framework...")
    cga_agent = CGAAgent(
        population_size=30,
        elite_threshold=0.2,
        crossover_rate=0.8,
        mutation_rate=0.15,
        max_generations=50
    )

    # Run optimization
    print("\n3. ðŸ§¬ Running Genetic Algorithm Optimization...")
    optimized_params = cga_agent.optimize(data, verbose=True)

    # Run backtest comparison
    print("\n4. ðŸ“ˆ Running Backtest Comparison...")
    baseline_results, optimized_results = backtester.run_comparison(
        baseline_params, optimized_params, data
    )

    # Calculate improvements
    improvement = backtester.calculate_improvement(baseline_results, optimized_results)

    # Generate report
    print("\n5. ðŸ“‹ Generating Performance Report...")
    report_df = backtester.generate_report(baseline_results, optimized_results, improvement)

    print("\n" + "="*60)
    print("ðŸ“Š PERFORMANCE COMPARISON REPORT")
    print("="*60)
    print(report_df.to_string(index=False))

    # Plot results
    print("\n6. ðŸ“Š Generating Comparison Charts...")
    backtester.plot_comparison(baseline_results, optimized_results)

    # Plot optimization progress
    print("\n7. ðŸ“ˆ Optimization Progress...")
    cga_agent.plot_optimization_progress()

    # Detailed parameter analysis
    print("\n8. ðŸ” Parameter Analysis:")
    print(f"   Baseline Parameters: {baseline_params}")
    print(f"   Optimized Parameters: {optimized_params}")

    # Key improvements summary
    print("\n9. ðŸŽ¯ Key Improvements Summary:")
    key_metrics = ['total_return', 'sharpe_ratio', 'sortino_ratio', 'max_drawdown']
    for metric in key_metrics:
        if metric in improvement:
            direction = "ðŸ“ˆ increase" if improvement[metric] > 0 else "ðŸ“‰ decrease"
            print(f"   {metric.replace('_', ' ').title():15}: {improvement[metric]:+6.1f}% ({direction})")

    return {
        'baseline_params': baseline_params,
        'optimized_params': optimized_params,
        'baseline_results': baseline_results,
        'optimized_results': optimized_results,
        'improvement': improvement,
        'report': report_df
    }

# Execute complete analysis
print("Starting CGA-Agent Crypto Trading Optimization...")
print("=" * 60)
results = run_complete_analysis()
print("\nâœ… Analysis completed successfully!")